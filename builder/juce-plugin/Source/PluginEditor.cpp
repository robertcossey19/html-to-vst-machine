#include "PluginEditor.h"
#include "BinaryData.h"   // auto-generated by JUCE (in JuceLibraryCode)

//==============================================================================

HtmlToVstAudioProcessorEditor::HtmlToVstAudioProcessorEditor (HtmlToVstAudioProcessor& p)
    : AudioProcessorEditor (&p),
      processor (p)
{
    // Basic editor size – tweak if you want
    setSize (1200, 700);

    addAndMakeVisible (webView);

    // We just want a flat, plugin-like background behind the browser
    webView.setOpaque (true);

    // Load the embedded HTML from BinaryData and show it
    loadEmbeddedHtml();
}

HtmlToVstAudioProcessorEditor::~HtmlToVstAudioProcessorEditor()
{
    // WebBrowserComponent cleans itself up
}

void HtmlToVstAudioProcessorEditor::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
}

void HtmlToVstAudioProcessorEditor::resized()
{
    webView.setBounds (getLocalBounds());
}

//==============================================================================
// Load HTML from BinaryData and feed it to WebBrowserComponent in a way Cubase
// will actually render, not show the encoded text.
//

void HtmlToVstAudioProcessorEditor::loadEmbeddedHtml()
{
    using namespace juce;

    // 1) Find a *.html resource in BinaryData
    const char* resourceName = nullptr;
    int dataSize = 0;

    if (BinaryData::namedResourceListSize > 0)
    {
        // Default to first resource
        resourceName = BinaryData::namedResourceList[0];

        // Prefer the first resource whose name ends with ".html" / ".htm"
        for (int i = 0; i < BinaryData::namedResourceListSize; ++i)
        {
            const String name (BinaryData::namedResourceList[i]);

            if (name.endsWithIgnoreCase (".html") || name.endsWithIgnoreCase (".htm"))
            {
                resourceName = BinaryData::namedResourceList[i];
                break;
            }
        }
    }

    const char* rawData = nullptr;

    if (resourceName != nullptr)
        rawData = BinaryData::getNamedResource (resourceName, dataSize);

    // 2) If we couldn’t find any HTML at all, show a simple fallback page
    if (rawData == nullptr || dataSize <= 0)
    {
        String fallbackHtml =
            "<html><body style='background:#101010; color:#eee; "
            "font-family:sans-serif; padding:16px;'>"
            "<h3>No embedded HTML UI found.</h3>"
            "<p>Rebuild the plug-in with your UI HTML added as a BinaryData resource.</p>"
            "</body></html>";

        // Use a proper data: URL with text/html so it renders correctly
        auto escaped = URL::addEscapeChars (fallbackHtml, true, true);
        auto dataUrl = "data:text/html;charset=utf-8," + escaped;
        webView.goToURL (dataUrl);
        return;
    }

    // 3) Decode UTF-8 HTML
    String html = String::fromUTF8 (rawData, dataSize);

    // 4) Write it to a temp file and point WebBrowser at file:// URL
    //    This avoids the “white page of encoded crap” problem and works
    //    better inside hosts like Cubase.
    auto tempDir  = File::getSpecialLocation (File::tempDirectory);
    auto htmlFile = tempDir.getChildFile ("HtmlToVstPlugin_UI.html");

    // Overwrite each time
    htmlFile.replaceWithText (html);

    // On macOS / Cubase this will look like "file:///var/folders/.../HtmlToVstPlugin_UI.html"
    auto urlString = htmlFile.getFullPathName();

    // Some hosts want an explicit file:// prefix for WebBrowserComponent
    if (! urlString.startsWithIgnoreCase ("file://"))
        urlString = "file://" + urlString;

    webView.goToURL (urlString);
}
