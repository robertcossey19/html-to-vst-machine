#include "PluginEditor.h"

// IMPORTANT: This header is generated by the HtmlUIData binarydata target.
// Your build already shows BinaryData1.cpp being compiled, so this should exist on include paths.
#include "BinaryData.h"

using namespace juce;

static String makeFallbackHtml (const String& extra)
{
    // Dark fallback (NOT a white text box)
    return "<!doctype html><html><head><meta charset='utf-8'/>"
           "<meta name='viewport' content='width=device-width,initial-scale=1'/>"
           "<title>UI Missing</title>"
           "<style>"
           "html,body{height:100%;margin:0;background:#111827;color:#e5e7eb;font-family:system-ui;}"
           ".wrap{display:flex;align-items:center;justify-content:center;height:100%;padding:16px;}"
           ".card{max-width:820px;border:1px solid #374151;border-radius:14px;background:rgba(0,0,0,.35);padding:18px;}"
           "code{display:block;white-space:pre-wrap;word-break:break-word;color:#cbd5e1;margin-top:10px;}"
           "</style></head><body><div class='wrap'><div class='card'>"
           "<h2 style='margin:0 0 10px 0'>Embedded UI not found</h2>"
           "<p style='margin:0 0 8px 0'>The plugin built, but the embedded HTML resource could not be located.</p>"
           "<p style='margin:0 0 8px 0'>This build searches BinaryData for an actual HTML payload and loads it as a temp .html file.</p>"
           + (extra.isNotEmpty() ? ("<code>" + extra + "</code>") : String())
           + "</div></div></body></html>";
}

static bool looksLikeHtml (const void* data, int size)
{
    if (data == nullptr || size < 16) return false;

    const int n = jmin (size, 512);
    const String head = String::fromUTF8 ((const char*) data, n).toLowerCase();

    return head.contains ("<!doctype")
        || head.contains ("<html")
        || head.contains ("<head")
        || head.contains ("tailwindcss");
}

static String findEmbeddedHtmlResourceName()
{
    // Pass 1: pick anything that literally contains "html"
    for (int i = 0; i < BinaryData::namedResourceListSize; ++i)
    {
        if (auto* nm = BinaryData::namedResourceList[i])
        {
            const String name (nm);
            if (name.containsIgnoreCase ("html") || name.containsIgnoreCase ("index"))
            {
                int size = 0;
                if (auto* data = BinaryData::getNamedResource (name.toRawUTF8(), size))
                    if (looksLikeHtml (data, size))
                        return name;
            }
        }
    }

    // Pass 2: brute force sniff all resources and take the first that looks like HTML
    for (int i = 0; i < BinaryData::namedResourceListSize; ++i)
    {
        if (auto* nm = BinaryData::namedResourceList[i])
        {
            const String name (nm);
            int size = 0;
            if (auto* data = BinaryData::getNamedResource (name.toRawUTF8(), size))
                if (looksLikeHtml (data, size))
                    return name;
        }
    }

    return {};
}

//==============================================================================
HtmlToVstAudioProcessorEditor::HtmlToVstAudioProcessorEditor (HtmlToVstAudioProcessor& p)
    : AudioProcessorEditor (&p), processor (p)
{
    setOpaque (true);

    // Web view
    addAndMakeVisible (webView);

    // Status overlay (small, not a giant white debug box)
    status.setText ("Loading UIâ€¦", dontSendNotification);
    status.setJustificationType (Justification::centredLeft);
    status.setColour (Label::textColourId, Colours::white.withAlpha (0.85f));
    status.setColour (Label::backgroundColourId, Colours::transparentBlack);
    status.setInterceptsMouseClicks (false, false);
    addAndMakeVisible (status);

    setSize (1020, 640);

    loadHtmlUi();

    // 30Hz UI update for VU
    startTimerHz (30);
}

HtmlToVstAudioProcessorEditor::~HtmlToVstAudioProcessorEditor()
{
    stopTimer();

    // Clean up temp file (optional)
    if (tempHtmlFile.existsAsFile())
        tempHtmlFile.deleteFile();
}

void HtmlToVstAudioProcessorEditor::paint (Graphics& g)
{
    // Never show a white editor background
    g.fillAll (Colour (0xFF111827));
}

void HtmlToVstAudioProcessorEditor::resized()
{
    auto r = getLocalBounds();
    status.setBounds (r.removeFromTop (26).reduced (10, 4));
    webView.setBounds (getLocalBounds());
}

void HtmlToVstAudioProcessorEditor::loadHtmlUi()
{
    const String resName = findEmbeddedHtmlResourceName();

    if (resName.isEmpty())
    {
        const auto html = makeFallbackHtml ("BinaryData contains no HTML-like payload.");
        tempHtmlFile = File::getSpecialLocation (File::tempDirectory).getChildFile ("HtmlToVstUI_fallback.html");
        tempHtmlFile.replaceWithText (html);
        webView.goToURL (URL (tempHtmlFile).withParameter ("t", String (Time::getMillisecondCounter())));
        status.setText ("UI missing (fallback)", dontSendNotification);
        return;
    }

    int size = 0;
    auto* data = BinaryData::getNamedResource (resName.toRawUTF8(), size);

    if (data == nullptr || size <= 0)
    {
        const auto html = makeFallbackHtml ("Found name, but BinaryData returned null: " + resName);
        tempHtmlFile = File::getSpecialLocation (File::tempDirectory).getChildFile ("HtmlToVstUI_fallback.html");
        tempHtmlFile.replaceWithText (html);
        webView.goToURL (URL (tempHtmlFile).withParameter ("t", String (Time::getMillisecondCounter())));
        status.setText ("UI missing (fallback)", dontSendNotification);
        return;
    }

    // Write embedded HTML bytes to a REAL .html file so WebKit renders it (no percent-encoded text)
    tempHtmlFile = File::getSpecialLocation (File::tempDirectory).getChildFile ("HtmlToVstUI_embedded.html");
    tempHtmlFile.deleteFile();
    tempHtmlFile.create();

    if (! tempHtmlFile.replaceWithData (data, (size_t) size))
    {
        const auto html = makeFallbackHtml ("Failed to write temp html file.");
        tempHtmlFile = File::getSpecialLocation (File::tempDirectory).getChildFile ("HtmlToVstUI_fallback.html");
        tempHtmlFile.replaceWithText (html);
        webView.goToURL (URL (tempHtmlFile).withParameter ("t", String (Time::getMillisecondCounter())));
        status.setText ("UI missing (fallback)", dontSendNotification);
        return;
    }

    webView.goToURL (URL (tempHtmlFile).withParameter ("t", String (Time::getMillisecondCounter())));
    status.setText ("UI loaded", dontSendNotification);
}

void HtmlToVstAudioProcessorEditor::timerCallback()
{
    // Pull dB RMS from processor, convert to linear, then let the HTML convert to dB for its needle math.
    const float lDb = processor.getVuLDb();
    const float rDb = processor.getVuRDb();

    const float lLin = Decibels::decibelsToGain (lDb);
    const float rLin = Decibels::decibelsToGain (rDb);

    const String js =
        "window.setVUMeters && window.setVUMeters("
        + String (lLin, 8) + "," + String (rLin, 8) + ");";

    webView.evaluateJavascript (js);
}
