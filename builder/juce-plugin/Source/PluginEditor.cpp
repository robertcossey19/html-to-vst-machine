#include "PluginEditor.h"

// NOTE: BinaryData.h is generated by the HtmlUIData target.
// It should be reachable via JuceHeader.h in your project, but include it explicitly if needed:
#if __has_include("BinaryData.h")
#include "BinaryData.h"
#endif

static juce::String urlDecode (juce::String s)
{
    s = s.replaceCharacter ('+', ' ');
    return juce::URL::removeEscapeChars (s);
}

HtmlToVstPluginAudioProcessorEditor::Browser::Browser (HtmlToVstPluginAudioProcessorEditor& ownerEditor)
: juce::WebBrowserComponent (juce::WebBrowserComponent::Options()
                                .withBackend (juce::WebBrowserComponent::Options::Backend::webview2)
                                .withNativeIntegrationEnabled()),
  owner (ownerEditor)
{
    // On macOS this will typically use WebKit backend; JUCE will pick what’s available.
}

bool HtmlToVstPluginAudioProcessorEditor::Browser::pageAboutToLoad (const juce::String& newURL)
{
    // Intercept our custom scheme
    if (newURL.startsWithIgnoreCase ("juce://"))
    {
        owner.handleJuceUrl (newURL);
        return false; // block navigation
    }

    return true;
}

HtmlToVstPluginAudioProcessorEditor::HtmlToVstPluginAudioProcessorEditor (HtmlToVstPluginAudioProcessor& p)
: AudioProcessorEditor (&p),
  processor (p),
  webView (*this)
{
    setSize (980, 620);
    addAndMakeVisible (webView);

    // Load UI
    webView.goToURL (makeUiDataUrl());

    // Start meter push + “keep UI synced”
    startTimerHz (30);
}

HtmlToVstPluginAudioProcessorEditor::~HtmlToVstPluginAudioProcessorEditor()
{
    stopTimer();
}

void HtmlToVstPluginAudioProcessorEditor::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
}

void HtmlToVstPluginAudioProcessorEditor::resized()
{
    webView.setBounds (getLocalBounds());
}

juce::String HtmlToVstPluginAudioProcessorEditor::makeUiDataUrl()
{
    // Try a few common BinaryData names; you can add more if your UI file is named differently.
    auto tryResource = [] (const char* name, int& sizeOut) -> const void*
    {
       #if defined(BinaryData)
        return BinaryData::getNamedResource (name, sizeOut);
       #else
        juce::ignoreUnused (name, sizeOut);
        return nullptr;
       #endif
    };

    int sz = 0;
    const void* data =
        tryResource ("index_html", sz) ? tryResource ("index_html", sz) :
        tryResource ("ui_index_html", sz) ? tryResource ("ui_index_html", sz) :
        tryResource ("resources_index_html", sz);

    if (data == nullptr || sz <= 0)
    {
        // Fallback: show a minimal page explaining missing BinaryData (still builds)
        const juce::String html =
            "<html><body style='background:#111;color:#eee;font-family:sans-serif'>"
            "<h2>UI BinaryData not found</h2>"
            "<p>Your HtmlUIData target didn’t embed an index.html file with an expected name.</p>"
            "<p>Fix: ensure your UI folder includes index.html and is added to juce_add_binary_data.</p>"
            "</body></html>";

        return "data:text/html;charset=utf-8," + juce::URL::addEscapeChars (html, true);
    }

    const juce::String html (juce::String::fromUTF8 ((const char*) data, sz));
    return "data:text/html;charset=utf-8," + juce::URL::addEscapeChars (html, true);
}

void HtmlToVstPluginAudioProcessorEditor::injectBridgeJS()
{
    // This JS:
    // - adds window.__juceSend(param,value)
    // - attaches listeners to common ids / data-param elements
    // - adds window.__juceSetMeters(in,out) for meter updates
    const juce::String js = R"JS(
(function(){
  if (window.__juceBridgeInstalled) return;
  window.__juceBridgeInstalled = true;

  window.__juceSend = function(param, value){
    try{
      var u = "juce://set?param=" + encodeURIComponent(param) + "&value=" + encodeURIComponent(String(value));
      window.location.href = u;
    }catch(e){}
  };

  window.__juceSetMeters = function(inLin, outLin){
    // Supports a few common meter element ids; harmless if not present
    var idsIn  = ["inMeter","inputMeter","vuIn","vu_in"];
    var idsOut = ["outMeter","outputMeter","vuOut","vu_out"];

    function setBar(id, v){
      var el = document.getElementById(id);
      if (!el) return;
      v = Math.max(0, Math.min(1, v));
      // If it's a <progress>
      if (el.tagName && el.tagName.toLowerCase() === "progress"){ el.value = v; return; }
      // If it has style width/height
      if (el.style){
        el.style.width  = (v*100) + "%";
        el.style.height = (v*100) + "%";
      }
      // If it’s a text readout
      if (el.innerText !== undefined && (el.dataset && el.dataset.meterText === "1")){
        el.innerText = (20*Math.log10(Math.max(1e-6, v))).toFixed(1) + " dB";
      }
    }

    idsIn.forEach(function(id){ setBar(id, inLin); });
    idsOut.forEach(function(id){ setBar(id, outLin); });
  };

  // Auto-wire elements:
  // - any element with data-param="inputGain" etc
  // - or common ids: inputGain, outputGain, drive, transformer
  function wire(el, param){
    if (!el) return;
    var tag = (el.tagName||"").toLowerCase();
    var isCheckbox = (tag === "input" && (el.type||"").toLowerCase() === "checkbox");

    var send = function(){
      var v = isCheckbox ? (el.checked ? 1 : 0) : (el.value !== undefined ? el.value : 0);
      window.__juceSend(param, v);
    };

    el.addEventListener("input", send);
    el.addEventListener("change", send);
  }

  // data-param wiring
  document.querySelectorAll("[data-param]").forEach(function(el){
    wire(el, el.getAttribute("data-param"));
  });

  // common id wiring
  wire(document.getElementById("inputGain"), "inputGain");
  wire(document.getElementById("outputGain"), "outputGain");
  wire(document.getElementById("drive"), "drive");
  wire(document.getElementById("transformer"), "transformer");
})();
)JS";

    webView.runJS (js);
}

void HtmlToVstPluginAudioProcessorEditor::handleJuceUrl (const juce::String& url)
{
    // Expect: juce://set?param=xxx&value=yyy
    if (! url.startsWithIgnoreCase ("juce://set?"))
        return;

    auto query = url.fromFirstOccurrenceOf ("?", false, false);

    auto getQueryValue = [&query] (const juce::String& key) -> juce::String
    {
        // super-simple query parser
        for (auto part : juce::StringArray::fromTokens (query, "&", ""))
        {
            auto kv = juce::StringArray::fromTokens (part, "=", "");
            if (kv.size() == 2 && kv[0] == key)
                return urlDecode (kv[1]);
        }
        return {};
    };

    const auto param = getQueryValue ("param");
    const auto value = getQueryValue ("value");

    if (param.isEmpty())
        return;

    auto* p = processor.apvts.getParameter (param);

    if (p == nullptr)
        return;

    // Convert incoming value:
    // - for bool: accept "1"/"0"/"true"/"false"
    // - for float params: assume it’s the real value in param range, not normalized
    float norm = 0.0f;

    if (dynamic_cast<juce::AudioParameterBool*> (p) != nullptr)
    {
        const bool b = (value == "1" || value.equalsIgnoreCase("true") || value.equalsIgnoreCase("on"));
        norm = b ? 1.0f : 0.0f;
        p->beginChangeGesture();
        p->setValueNotifyingHost (norm);
        p->endChangeGesture();
        return;
    }

    // float param: map from text to range -> normalized
    const float v = value.getFloatValue();
    const auto range = p->getNormalisableRange();
    norm = range.convertTo0to1 (v);

    p->beginChangeGesture();
    p->setValueNotifyingHost (juce::jlimit (0.0f, 1.0f, norm));
    p->endChangeGesture();
}

void HtmlToVstPluginAudioProcessorEditor::timerCallback()
{
    // After page load, inject bridge once (safe to call repeatedly)
    injectBridgeJS();

    // Push meters into UI
    const float inM  = processor.getInputMeter();
    const float outM = processor.getOutputMeter();

    const juce::String js =
        "if (window.__juceSetMeters) window.__juceSetMeters("
        + juce::String (inM, 6) + ","
        + juce::String (outM, 6) + ");";

    webView.runJS (js);
}
