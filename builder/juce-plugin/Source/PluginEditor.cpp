#include "PluginEditor.h"
#include "PluginProcessor.h"

// This is generated by your HtmlUIData target (JUCE BinaryData)
#include <BinaryData.h>

using namespace juce;

static bool endsWithIgnoreCase (const String& s, const String& suffix)
{
    return s.endsWithIgnoreCase (suffix);
}

static String percentEncodeForDataUrl (const String& in)
{
    // Keep it simple + safe for data:text/html, URL payload.
    // Encode everything except a small safe set.
    auto isSafe = [] (juce_wchar c)
    {
        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))
            return true;

        switch ((char) c)
        {
            case '-': case '_': case '.': case '~':
            case '/': case ':': case '?': case '#':
            case '[': case ']': case '@':
            case '!': case '$': case '&': case '\'': case '(':
            case ')': case '*': case '+': case ',': case ';': case '=':
                return true;
            default:
                return false;
        }
    };

    String out;
    out.preallocateBytes (in.getNumBytesAsUTF8() * 3);

    for (auto c : in)
    {
        if (isSafe (c))
        {
            out << String::charToString ((juce_wchar) c);
        }
        else if (c == ' ')
        {
            out << "%20";
        }
        else
        {
            // Convert this character to UTF-8 bytes and encode each byte.
            char utf8[8] = {};
            auto n = CharPointer_UTF8::write (utf8, (size_t) 8, c);
            for (int i = 0; i < (int) n; ++i)
            {
                auto b = (unsigned char) utf8[i];
                out << "%" << String::toHexString ((int) b).paddedLeft ('0', 2).toUpperCase();
            }
        }
    }
    return out;
}

static String makeMissingUiHtml (const String& extra)
{
    // This is intentionally DARK so you never get the “white wall of text”.
    return R"HTML(<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>UI Missing</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0f16;color:#e6edf7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:18px}
    .card{max-width:860px;width:100%;border:1px solid #1f2937;border-radius:14px;background:rgba(255,255,255,.04);padding:18px}
    h2{margin:0 0 8px 0;font-size:18px}
    p{margin:6px 0;color:#9aa4b2;line-height:1.35}
    code{display:block;margin-top:10px;padding:12px;border-radius:10px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.06);white-space:pre-wrap;word-break:break-word;color:#d1d5db}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2>Embedded UI not found</h2>
      <p>The plugin built, but the embedded HTML resource name didn’t match what the editor expects.</p>
      <p>Fix: confirm the embedded file name in <b>BinaryData</b> and ensure it is included in the build step that generates BinaryData.</p>
      <code>)HTML" + extra + R"HTML(</code>
    </div>
  </div>
</body>
</html>)HTML";
}

static String findBestHtmlResourceName()
{
    // Scan BinaryData for something that looks like an HTML file.
    // (Works even if your build system renames it.)
    for (int i = 0; i < BinaryData::namedResourceListSize; ++i)
    {
        if (auto* nm = BinaryData::namedResourceList[i])
        {
            const String name (nm);
            if (endsWithIgnoreCase (name, ".html") || endsWithIgnoreCase (name, ".htm"))
                return name;
        }
    }

    // Fallback: sometimes it’s embedded without extension.
    for (int i = 0; i < BinaryData::namedResourceListSize; ++i)
    {
        if (auto* nm = BinaryData::namedResourceList[i])
        {
            const String name (nm);
            if (name.containsIgnoreCase ("index") || name.containsIgnoreCase ("ui"))
                return name;
        }
    }

    return {};
}

static bool loadHtmlFromBinaryData (String& outHtml, String& outPickedName)
{
    outPickedName = findBestHtmlResourceName();
    if (outPickedName.isEmpty())
        return false;

    int size = 0;
    if (auto* data = BinaryData::getNamedResource (outPickedName.toRawUTF8(), size))
    {
        outHtml = String::fromUTF8 ((const char*) data, size).trim();
        return outHtml.isNotEmpty();
    }

    return false;
}

HtmlToVstAudioProcessorEditor::HtmlToVstAudioProcessorEditor (HtmlToVstAudioProcessor& p)
    : AudioProcessorEditor (&p), processor (p)
{
    setSize (1100, 680);

    addAndMakeVisible (webView);

    String html, pickedName;
    if (loadHtmlFromBinaryData (html, pickedName))
    {
        // If the HTML is already percent-encoded (starts with %3C...), do NOT double encode it.
        const bool looksAlreadyEncoded =
            html.startsWithIgnoreCase ("%3C") || (html.contains ("%3C%21DOCTYPE") && ! html.containsIgnoreCase ("<html"));

        const String payload = looksAlreadyEncoded ? html : percentEncodeForDataUrl (html);

        const String dataUrl = "data:text/html;charset=utf-8," + payload;

        // IMPORTANT: this is what prevents the “white box full of text”.
        webView.goToURL (dataUrl);
    }
    else
    {
        const String extra = "BinaryData entries:\n" + String (BinaryData::namedResourceListSize) + "\n";
        const String payload = percentEncodeForDataUrl (makeMissingUiHtml (extra));
        webView.goToURL ("data:text/html;charset=utf-8," + payload);
    }

    startTimerHz (30);
}

HtmlToVstAudioProcessorEditor::~HtmlToVstAudioProcessorEditor()
{
    stopTimer();
}

void HtmlToVstAudioProcessorEditor::paint (Graphics& g)
{
    // Backstop paint (host can show black while WebView boots)
    g.fillAll (Colour (0xFF0B0F16));
}

void HtmlToVstAudioProcessorEditor::resized()
{
    webView.setBounds (getLocalBounds());
}

void HtmlToVstAudioProcessorEditor::timerCallback()
{
    // Processor stores dB RMS (per your PluginProcessor.cpp).
    // Your JS expects linear, and converts to dB itself.
    const float lDb = processor.getCurrentVUL();
    const float rDb = processor.getCurrentVUR();

    const float lLin = Decibels::decibelsToGain (lDb, -100.0f);
    const float rLin = Decibels::decibelsToGain (rDb, -100.0f);

    const String js =
        "if (window.setVUMeters) { window.setVUMeters("
        + String (lLin, 6) + ","
        + String (rLin, 6) + "); }";

    webView.evaluateJavascript (js);
}
