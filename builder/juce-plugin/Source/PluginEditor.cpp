#include "PluginEditor.h"

// BinaryData.h is generated by your HtmlUIData target.
// In a proper JUCE+CMake setup, it is on the include path.
// If your build ever can't find it, that's a build-system issue (include dirs / linking HtmlUIData).
#include "BinaryData.h"

static juce::String urlDecode (juce::String s)
{
    s = s.replaceCharacter ('+', ' ');
    return juce::URL::removeEscapeChars (s);
}

// Try to locate an embedded "index.html" (or equivalent) by scanning the generated list.
static const void* findEmbeddedIndexHtml (int& sizeOut)
{
    sizeOut = 0;

    // First: direct hits (common names)
    if (auto* p = BinaryData::getNamedResource ("index_html", sizeOut)) return p;
    if (auto* p = BinaryData::getNamedResource ("ui_index_html", sizeOut)) return p;
    if (auto* p = BinaryData::getNamedResource ("resources_index_html", sizeOut)) return p;

    // Second: scan the list for anything that looks like an index html
    // BinaryData::namedResourceList is a null-terminated const char* array.
    for (const char* const* n = BinaryData::namedResourceList; *n != nullptr; ++n)
    {
        juce::String name (*n);

        // JUCE turns file names into identifiers; "index.html" typically becomes "index_html"
        // but if it was in a folder it may become "somefolder_index_html".
        if (name.endsWithIgnoreCase ("index_html"))
        {
            if (auto* p = BinaryData::getNamedResource (*n, sizeOut))
                return p;
        }
    }

    // Third: scan for any html at all (better than blank UI)
    for (const char* const* n = BinaryData::namedResourceList; *n != nullptr; ++n)
    {
        juce::String name (*n);
        if (name.endsWithIgnoreCase ("_html") || name.endsWithIgnoreCase ("_htm"))
        {
            if (auto* p = BinaryData::getNamedResource (*n, sizeOut))
                return p;
        }
    }

    return nullptr;
}

HtmlToVstPluginAudioProcessorEditor::Browser::Browser (HtmlToVstPluginAudioProcessorEditor& ownerEditor)
    : juce::WebBrowserComponent (juce::WebBrowserComponent::Options()
                                    .withNativeIntegrationEnabled()),
      owner (ownerEditor)
{
}

bool HtmlToVstPluginAudioProcessorEditor::Browser::pageAboutToLoad (const juce::String& newURL)
{
    // Intercept our custom scheme
    if (newURL.startsWithIgnoreCase ("juce://"))
    {
        owner.handleJuceUrl (newURL);
        return false; // block navigation
    }
    return true;
}

HtmlToVstPluginAudioProcessorEditor::HtmlToVstPluginAudioProcessorEditor (HtmlToVstPluginAudioProcessor& p)
    : AudioProcessorEditor (&p),
      processor (p),
      webView (*this)
{
    setSize (980, 620);
    addAndMakeVisible (webView);

    // Load UI
    webView.goToURL (makeUiDataUrl());

    // Push meters + keep UI synced
    startTimerHz (30);
}

HtmlToVstPluginAudioProcessorEditor::~HtmlToVstPluginAudioProcessorEditor()
{
    stopTimer();
}

void HtmlToVstPluginAudioProcessorEditor::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);
}

void HtmlToVstPluginAudioProcessorEditor::resized()
{
    webView.setBounds (getLocalBounds());
}

juce::String HtmlToVstPluginAudioProcessorEditor::makeUiDataUrl()
{
    int sz = 0;
    const void* data = findEmbeddedIndexHtml (sz);

    if (data == nullptr || sz <= 0)
    {
        // Fallback: show a minimal page explaining missing BinaryData (still builds)
        const juce::String html =
            "<html><body style='background:#111;color:#eee;font-family:sans-serif'>"
            "<h2>UI BinaryData not found</h2>"
            "<p>Your HtmlUIData target didnâ€™t embed an index.html file with an expected name.</p>"
            "<p><b>Fix:</b> ensure your UI folder includes <code>index.html</code> and is added to juce_add_binary_data.</p>"
            "</body></html>";

        return "data:text/html;charset=utf-8," + juce::URL::addEscapeChars (html, true);
    }

    const juce::String html (juce::String::fromUTF8 ((const char*) data, sz));
    return "data:text/html;charset=utf-8," + juce::URL::addEscapeChars (html, true);
}

void HtmlToVstPluginAudioProcessorEditor::injectBridgeJS()
{
    // JS bridge:
    // - window.__juceSend(param,value) -> navigates to juce://set?param=...&value=...
    // - auto-wires elements with [data-param] and common ids
    // - window.__juceSetMeters(in,out) for meter updates
    const juce::String js = R"JS(
(function(){
  if (window.__juceBridgeInstalled) return;
  window.__juceBridgeInstalled = true;

  window.__juceSend = function(param, value){
    try{
      var u = "juce://set?param=" + encodeURIComponent(param) + "&value=" + encodeURIComponent(String(value));
      window.location.href = u;
    }catch(e){}
  };

  window.__juceSetMeters = function(inLin, outLin){
    var idsIn = ["inMeter","inputMeter","vuIn","vu_in"];
    var idsOut = ["outMeter","outputMeter","vuOut","vu_out"];

    function clamp01(v){ return Math.max(0, Math.min(1, v)); }

    function setBar(id, v){
      var el = document.getElementById(id);
      if (!el) return;
      v = clamp01(v);

      if (el.tagName && el.tagName.toLowerCase() === "progress"){
        el.value = v;
        return;
      }

      if (el.style){
        // handles bar meters
        el.style.width = (v*100) + "%";
        el.style.height = (v*100) + "%";
      }

      // optional text meter if you tag it: data-meter-text="1"
      if (el.dataset && el.dataset.meterText === "1"){
        var db = 20*Math.log10(Math.max(1e-6, v));
        el.innerText = db.toFixed(1) + " dB";
      }
    }

    idsIn.forEach(function(id){ setBar(id, inLin); });
    idsOut.forEach(function(id){ setBar(id, outLin); });
  };

  function wire(el, param){
    if (!el) return;
    var tag = (el.tagName||"").toLowerCase();
    var isCheckbox = (tag === "input" && (el.type||"").toLowerCase() === "checkbox");

    var send = function(){
      var v = isCheckbox ? (el.checked ? 1 : 0)
                         : (el.value !== undefined ? el.value : 0);
      window.__juceSend(param, v);
    };

    el.addEventListener("input", send);
    el.addEventListener("change", send);
  }

  // data-param wiring
  document.querySelectorAll("[data-param]").forEach(function(el){
    wire(el, el.getAttribute("data-param"));
  });

  // common id wiring (safe if missing)
  wire(document.getElementById("inputGain"), "inputGain");
  wire(document.getElementById("outputGain"), "outputGain");
  wire(document.getElementById("drive"), "drive");
  wire(document.getElementById("transformer"), "transformer");
})();
)JS";

    webView.runJS (js);
}

void HtmlToVstPluginAudioProcessorEditor::handleJuceUrl (const juce::String& url)
{
    // Expect: juce://set?param=xxx&value=yyy
    if (! url.startsWithIgnoreCase ("juce://set?"))
        return;

    const auto query = url.fromFirstOccurrenceOf ("?", false, false);

    auto getQueryValue = [&query] (const juce::String& key) -> juce::String
    {
        for (auto part : juce::StringArray::fromTokens (query, "&", ""))
        {
            auto kv = juce::StringArray::fromTokens (part, "=", "");
            if (kv.size() == 2 && kv[0] == key)
                return urlDecode (kv[1]);
        }
        return {};
    };

    const auto param = getQueryValue ("param");
    const auto value = getQueryValue ("value");

    if (param.isEmpty())
        return;

    auto* p = processor.apvts.getParameter (param);
    if (p == nullptr)
        return;

    // Bool-ish: treat 1/0/true/false
    if (auto* bp = dynamic_cast<juce::AudioParameterBool*> (p))
    {
        const bool b = (value == "1" || value.equalsIgnoreCase ("true") || value.equalsIgnoreCase ("on"));
        bp->beginChangeGesture();
        bp->setValueNotifyingHost (b ? 1.0f : 0.0f);
        bp->endChangeGesture();
        return;
    }

    // Float-like: assume incoming is "real value", map to normalized
    const float v = value.getFloatValue();
    const auto range = p->getNormalisableRange();
    const float norm = juce::jlimit (0.0f, 1.0f, range.convertTo0to1 (v));

    p->beginChangeGesture();
    p->setValueNotifyingHost (norm);
    p->endChangeGesture();
}

void HtmlToVstPluginAudioProcessorEditor::timerCallback()
{
    // After page load, inject bridge once (safe to call repeatedly)
    injectBridgeJS();

    // Push meters into UI
    const float inM  = processor.getInputMeter();
    const float outM = processor.getOutputMeter();

    const juce::String js =
        "if (window.__juceSetMeters) window.__juceSetMeters("
        + juce::String (inM, 6) + "," + juce::String (outM, 6) + ");";

    webView.runJS (js);
}
