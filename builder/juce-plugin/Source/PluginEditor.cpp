#include "PluginProcessor.h"
#include "PluginEditor.h"

// This header is generated by juce_add_binary_data(HtmlUIData …)
#include "BinaryData.h"

using namespace juce;

//==============================================================================

HtmlToVstAudioProcessorEditor::HtmlToVstAudioProcessorEditor (HtmlToVstAudioProcessor& p)
    : AudioProcessorEditor (&p), processor (p)
{
    setSize (1200, 620);

    // Optional: choose native vs webview. For now let JUCE decide:
    // (If you wanted to force the OS webview: uncomment the next line)
    // webView = std::make_unique<WebBrowserComponent> (WebBrowserComponent::Options{}.withNative());

    addAndMakeVisible (webView);

    // -------------------------------------------------------------------------
    // Write the bundled HTML to a temp file and load it via file:// URL.
    // This avoids data: URL encoding issues and makes hosts/WebView happy.
    // -------------------------------------------------------------------------
    {
        // Decode the HTML from BinaryData
        const char* htmlData   = BinaryData::ampex_ui_html;
        const int   htmlSize   = BinaryData::ampex_ui_htmlSize;
        const String html      = String::fromUTF8 (htmlData, htmlSize);

        // Temp folder: ~/Library/Caches/AnalogExact/HTMLToVST/ampex_ui.html
        File baseDir = File::getSpecialLocation (File::userApplicationDataDirectory)
                           .getChildFile ("AnalogExact")
                           .getChildFile ("HTMLToVST");

        baseDir.createDirectory(); // safe if it already exists

        tempHtmlFile = baseDir.getChildFile ("ampex_ui.html");

        // Write the HTML to disk
        bool ok = tempHtmlFile.replaceWithText (html);

        if (ok)
        {
            webView.goToURL (tempHtmlFile.getFullPathName());
        }
        else
        {
            // Fallback: show a simple error page
            webView.goToURL ("data:text/html,<html><body><h3>Failed to load UI HTML</h3></body></html>");
        }
    }

    // Start VU meter updates from the processor
    startTimerHz (30); // ~33 ms
}

HtmlToVstAudioProcessorEditor::~HtmlToVstAudioProcessorEditor()
{
    stopTimer();
}

//==============================================================================

void HtmlToVstAudioProcessorEditor::paint (Graphics& g)
{
    // We let the WebView paint everything. Just fill background behind it.
    g.fillAll (Colours::black);
}

void HtmlToVstAudioProcessorEditor::resized()
{
    webView.setBounds (getLocalBounds());
}

//==============================================================================
// VU bridge: called ~30x/sec, pushes levels into the HTML via JS
// The HTML defines window.setVUMeters(left, right) in dB or linear – here we
// assume dB and call window.setVUMeters(lDb, rDb)
//==============================================================================

void HtmlToVstAudioProcessorEditor::timerCallback()
{
    // These accessors already exist in your processor (we used them earlier
    // as getCurrentVUL()/getCurrentVUR())
    const float lDb = processor.getCurrentVUL();
    const float rDb = processor.getCurrentVUR();

    // Build the JS string that the HTML side expects
    String js;
    js << "if (window.setVUMeters) window.setVUMeters("
       << String (lDb, 3) << ", " << String (rDb, 3) << ");";

    // New JUCE API: evaluateJavascript instead of executeJavascript
    webView.evaluateJavascript (js, nullptr);
}
